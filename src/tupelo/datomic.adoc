

= Tupelo: Making Datomic Even Sweeter

Leiningen coordinates:   

image:http://clojars.org/tupelo/latest-version.svg[ http://clojars.org/tupelo ]

=== API Docs:   http://cloojure.github.io/doc/tupelo/

== Overview

Have you ever wanted to jump into using Datomic but been wishing for a simpler starting point? If
so, then Tupelo Datomic is for you.  The goal of Tupelo Datomic is to automatate all of the detail
that rarely changes or is needed when dealing with Datomic, making your job nearly effortless.

Suppose we're trying to keep track of information for the world's premiere spy agency. Let's create
a few attributes that will apply to our heroes & villains (see the executable code 
link:../../test/tst/tupelo/datomic_bond.clj[in the unit test]).

[source,clojure]
----
  (:require [tupelo.datomic   :as td]
            [tupelo.schema    :as ts])

  ; Create some new attributes. Required args are the attribute name (an optionally namespaced
  ; keyword) and the attribute type (full listing at http://docs.datomic.com/schema.html). We wrap
  ; the new attribute definitions in a transaction and immediately commit them into the DB.
  (td/transact *conn* ;   required              required              zero-or-more
                      ;  <attr name>         <attr value type>       <optional specs ...>
    (td/new-attribute   :person/name         :db.type/string         :db.unique/value)      ; each name      is unique
    (td/new-attribute   :person/secret-id    :db.type/long           :db.unique/value)      ; each secret-id is unique
    (td/new-attribute   :weapon/type         :db.type/ref            :db.cardinality/many)  ; one may have many weapons
    (td/new-attribute   :location            :db.type/string)     ; all default values
    (td/new-attribute   :favorite-weapon     :db.type/keyword ))  ; all default values
----

For the `:weapon/type` attribute, we want to use an enumerated type since there are only a limited
number of choices available to our antagonists:

[source,clojure]
----
  ; Create some "enum" values. These are degenerate entities that serve the same purpose as an
  ; enumerated value in Java (these entities will never have any attributes). Again, we
  ; wrap our new enum values in a transaction and commit them into the DB. 
  (td/transact *conn* 
    (td/new-enum :weapon/gun)
    (td/new-enum :weapon/knife)
    (td/new-enum :weapon/guile)
    (td/new-enum :weapon/wit))
----

Let's create a few antagonists and load them into the DB. Note that we are just using plain Clojure
values and literals here, and we don't have to worry about any Datomic specific conversions.

[source,clojure]
----
  ; Create some antagonists and load them into the db.  We can specify some of the attribute-value
  ; pairs at the time of creation, and add others later. Note that whenever we are adding multiple
  ; values for an attribute in a single step (e.g. :weapon/type), we must wrap all of the values
  ; in a set. Note that the set implies there can never be duplicate weapons for any one person.
  ; As before, we immediately commit the new entities into the DB.
  (td/transact *conn* 
    (td/new-entity { :person/name "James Bond" :location "London"     :weapon/type #{ :weapon/gun :weapon/wit   } } )
    (td/new-entity { :person/name "M"          :location "London"     :weapon/type #{ :weapon/gun :weapon/guile } } )
    (td/new-entity { :person/name "Dr No"      :location "Caribbean"  :weapon/type    :weapon/gun                 } ))
----

And, just like that, we have values persisted in the DB! Let's check that they are really there:

[source,clojure]
----
  ; Verify the antagonists were added to the DB
  (let [people (get-people (live-db)) ]
    (is (= people   
           #{ {:person/name "James Bond"    :location "London"      :weapon/type #{:weapon/wit    :weapon/gun} }
              {:person/name "M"             :location "London"      :weapon/type #{:weapon/guile  :weapon/gun} }
              {:person/name "Dr No"         :location "Caribbean"   :weapon/type #{:weapon/gun               } } } )))
----

== EntitySpec, EntityID, and LookupRef

Entities in Datomic are specified using an EntitySpec, which is either an EntityID (EID) or a
LookupRef.

An EntityID (EID) is a globally unique Long value that uniquely specifies any entity in the Datomic
DB. These are always positive for committed entities in Datomic (negative values indicate temporary
EIDs used only in building transactions).

A LookupRef is an attribute-value pair (wrapped in a vector), which uniquely specifies an entity.
If an entity has an attribute specified as either :db.unique/value or :db.unique/identity, that
entity may be specified using a LookupRef.

Here we verify that we can find James Bond and retrieve all of his attr-val pairs using either type
of EntitySpec:

[source,clojure]
----
  ; Using James' name, lookup his EntityId (EID). 
  (let [james-eid   (td/query-scalar  :let    [$ (live-db)]     ; like Clojure let
                                      :find   [?eid]
                                      :where  [ [?eid :person/name "James Bond"] ] )
        ; Retrieve James' attr-val pairs as a map. An entity can be referenced either by EID or by a
        ; LookupRef, which is a unique attribute-value pair expressed as a vector.
        james-map   (td/entity-map (live-db) james-eid)                       ; use EID  
        james-map2  (td/entity-map (live-db) [:person/name "James Bond"] )    ; use LookupRef
  ]
    (is (= james-map {:person/name "James Bond" :location "London" 
                      :weapon/type #{:weapon/wit :weapon/gun} } ))
    (is (= james-map james-map2 ))
----

We can also use either type of EntitySpec for update

[source,clojure]
----
    ; Update the database with more weapons.  If we overwrite some items that are already present
    ; (e.g. :weapon/gun) it is idempotent (no duplicates are allowed).  The first arg to td/update
    ; is an EntitySpec (either EntityId or LookupRef) and determines the Entity that is updated.
    (td/transact *conn* 
      (td/update james-eid   ; update using EID
          { :weapon/type #{ :weapon/gun :weapon/knife }
            :person/secret-id 007 } )   ; Note that James has a secret-id but no one else does

      (td/update [:person/name "Dr No"] ; update using LookupRef
        { :weapon/type #{ :weapon/gun :weapon/knife :weapon/guile } } )))

----

As expected, our database contains the updated values for Dr No and James Bond. Notice that, since
`:weapon/type` is implemented as a set in Datmoic, duplicate values are not allowed and both
antagonists have only a single gun:

[source,clojure]
----
  ; Verify current status. Notice there are no duplicate weapons.
  (let [people (get-people (live-db)) ]
    (is (= people   
      #{ { :person/name "James Bond" :location "London" :weapon/type #{:weapon/wit :weapon/knife :weapon/gun} :person/secret-id 7 }
         { :person/name "M" :location "London"          :weapon/type #{:weapon/guile :weapon/gun} }
         { :person/name "Dr No" :location "Caribbean"   :weapon/type #{:weapon/guile :weapon/knife :weapon/gun} } } )))
----

== Enum Values

The benefit of using enumerated values in Datomic is that we can easily restrict the the domain of
acceptable values more easily than by using plain keyword values. For example, if we try to give
James a non-existant weapon, Datomic will generate an exception:

[source,clojure]
----
  ; Try to add non-existent weapon. This throws since the bogus kw does not match up with an entity.
  (is (thrown? Exception   @(td/transact *conn* 
                              (td/update [:person/name "James Bond"] ; update using a LookupRef
                                { :weapon/type #{ :there.is/no-such-kw } } ))))  ; bogus value for :weapon/type causes exception

----

=== tupelo.datomic - Basic functions

==== new-attribute

details here...

-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
link:src/tupelo/explicit.adoc[Documentation for tupelo.explicit]

=== tupelo.csv - Functions for using CSV (Comma Separate Value) files

The standard link:http://github.com/davidsantiago/clojure-csv[clojure-csv library] has well-tested and useful functions for parsing 
CSV (Comma Separated Value) text data, but it does not offer all of the convenience one
may wish. In `tupelo.csv` we emphasize the idomatic Clojure usage of data, using
sequences and maps.

link:src/tupelo/csv.adoc[Documentation for tupelo.csv]

=== tupelo.parse - Functions to ease parsing

TEMP TODO:  see http://cloojure.github.io/tupelo/tupelo.parse.html

=== tupelo.base64 - Convert to/from base64 encoding

TEMP TODO:  see http://cloojure.github.io/tupelo/tupelo.base64.html

=== tupelo.y64 - Convert to/from the URL-safe Y64 encoding (Yahoo YUI library).

TEMP TODO:  see http://cloojure.github.io/tupelo/tupelo.y64.html

== License

Copyright Â© 2015 Alan Thompson. 

Distributed under the Eclipse Public License, the same as Clojure.
